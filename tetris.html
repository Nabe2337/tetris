<!-- event.keycodeはキー番号 -->
<body onKeyDown=K=event.keyCode-38><script>
  <!-- 変数の初期化 -->
  <!-- Aは定数．ゲームフィールドの横一列の大きさ（壁含む） -->
  <!-- Bは各パーツのブロックを表す配列．例えばB=[0, 1, 2, 3]はテトリス棒を表す -->
  <!-- Zは落下中のパーツは含まないゲームフィールド配列．確定したブロックおよび壁を表す -->
  <!-- Xは落下中のパーツを含めたゲームフィールド配列（X = Z + B） -->
 Z=X=[];B=A=12;
 <!-- メイン関数 -->
 function Y(){
  <!-- Cは回転先の座標 -->
   C=[]; 
   <!-- 移動先・回転先の座標計算と障害物判定(キー入力Kが0ならばforは処理されない) -->
   for(q=c=i=4;i--*K;){
    <!-- 4つのブロックごとに座標計算 -->
     p=B[i];
     <!-- ここで(x, y)を(-y, x)にしている -->
     <!-- なお，座標はx+y*12で一次元の数で表しているので，以下のような式 -->
     C[i]=p*A-(p/9|0)*145;
     <!-- 移動先に障害物があるかどうか -->
     <!-- h+p+Kが横移動の移動先座標，h+C[i]が回転先座標 -->
     <!-- そこの座標のZが壁あるいはブロックの場合はc!=0(移動先に障害物あり) c==0ならば移動・回転可能-->
     c-=!Z[h+(K+25?p+K:C[i])];
   }
   <!-- cの値によって横移動か回転の実行-->
   <!-- 横移動は現在位置をh+Kにし，回転はB[]をC[]に置き換え-->
   <!-- t==0は四角形のパーツなので回転させない -->
  c?0:K+25?h+=K:t?B=C:0;
  <!-- f:落下先にブロックがあるかどうか -->
  <!-- k:得点 -->
  <!-- 各ブロックの位置h+B[q]におけるX[]を1としてブロックの描画 -->
  <!-- 落下先の座標のフィールド状態Z[]をfに加算 -->
  for(f=K=0;q--;){
    k=X[p=h+B[q]]=1;
    f+=Z[A+p];
  }
  if(e=!e){
    h+=A;
    <!-- 接地判定および初期化判定 -->
    if(f|B){
      <!-- 落下した状態の行列Xを新たなゲームフィールドZに設定 -->
      Z=X,X=[],
      <!-- 新しいパーツの生成 -->
      B=[[-7,-20,6,h=17,-9,3,3][t=++t%7]-4,0,1,t-6?-A:2];
      <!-- 一行揃い判定および一列消去 -->
      <!-- ここまででタイムアップです -->
      for(l=228;l--;){
        for(l%A?l-=l%A*!Z[l]:(P+=k++,c=l+=A);--c>A;){
          Z[c]=Z[c-A];
        }
      }
    }
  }
  for(i=S="";i<240;){
    S+=X[i]|(X[i]=Z[i]|=++i%A<2|i>228)?i%A?"■":"■<br>":"＿";
  }
  document.body.innerHTML=S+P;
  Z[5]||setTimeout(Y,99-P)
}
Y(h=e=K=t=P=0)
</script>


